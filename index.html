<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Marble Ludo â€“ Layout</title>

  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f2f2f2;
      text-align: center;
    }

    canvas {
      background: white;
      border: 2px solid black;
      margin-top: 20px;
    }
  </style>
</head>
<body>

<h2>Marble Ludo â€“ Board Layout</h2>

<canvas id="board" width="400" height="400"></canvas>

<script>
/* =========================
   BOARD CONFIG
========================= */

const GRID_SIZE = 5;
const CELL_SIZE = 80;

const canvas = document.getElementById("board");
const ctx = canvas.getContext("2d");

/* =========================
   BOARD DATA (LAYOUT ONLY)
========================= */
/*
0 = normal square
1 = safe zone
2 = finish
*/

const board = [
  [0, 0, 1, 0, 0],
  [0, 0, 0, 0, 0],
  [1, 0, 2, 0, 1],
  [0, 0, 0, 0, 0],
  [0, 0, 1, 0, 0]
];

/* =========================
   DRAW BOARD
========================= */

function drawBoard() {
  for (let y = 0; y < GRID_SIZE; y++) {
    for (let x = 0; x < GRID_SIZE; x++) {

      // Choose color
      if (board[y][x] === 1) {
        ctx.fillStyle = "#f4a261"; // safe
      } else if (board[y][x] === 2) {
        ctx.fillStyle = "#90dbf4"; // finish
      } else {
        ctx.fillStyle = "#ffffff"; // normal
      }

      ctx.fillRect(
        x * CELL_SIZE,
        y * CELL_SIZE,
        CELL_SIZE,
        CELL_SIZE
      );

      ctx.strokeRect(
        x * CELL_SIZE,
        y * CELL_SIZE,
        CELL_SIZE,
        CELL_SIZE
      );

      // Finish text
      if (board[y][x] === 2) {
        ctx.fillStyle = "black";
        ctx.font = "14px Arial";
        ctx.fillText(
          "FINISH",
          x * CELL_SIZE + 15,
          y * CELL_SIZE + 45
        );
      }
    }
  }
}

drawBoard();
</script>

</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Marble Ludo â€“ Outer & Inner Loop</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background: #f2f2f2;
    }
    canvas {
      background: white;
      border: 2px solid black;
      margin-top: 15px;
    }
    button {
      margin-top: 10px;
      padding: 8px 16px;
      font-size: 16px;
    }
  </style>
</head>
<body>

<h2>Marble Ludo â€“ Movement Test</h2>
<button onclick="moveToken()">Move 1 Step</button>

<canvas id="board" width="400" height="400"></canvas>

<script>
/* =========================
   CONFIG
========================= */
const GRID = 5;
const CELL = 80;

/* =========================
   BOARD LAYOUT
   0 = normal
   1 = safe
   2 = finish
========================= */
const board = [
  [0,0,1,0,0],
  [0,0,0,0,0],
  [1,0,2,0,1],
  [0,0,0,0,0],
  [0,0,1,0,0]
];

/* =========================
   OUTER LOOP (ANTICLOCKWISE)
========================= */
const outerPath = [
  {x:0,y:0},{x:1,y:0},{x:2,y:0},{x:3,y:0},{x:4,y:0},
  {x:4,y:1},{x:4,y:2},{x:4,y:3},{x:4,y:4},
  {x:3,y:4},{x:2,y:4},{x:1,y:4},{x:0,y:4},
  {x:0,y:3},{x:0,y:2},{x:0,y:1}
];

/* =========================
   INNER LOOP (CLOCKWISE)
========================= */
const innerPath = [
  {x:2,y:3},
  {x:3,y:2},
  {x:2,y:1},
  {x:1,y:2}
];

/* =========================
   SPECIAL POSITIONS
========================= */
const START = {x:2,y:4};      // P1
const INNER_ENTRY = {x:1,y:4};
const FINISH = {x:2,y:2};

/* =========================
   TOKEN STATE
========================= */
let mode = "outer";   // outer | inner | finish
let outerIndex = outerPath.findIndex(
  p => p.x === START.x && p.y === START.y
);
let innerIndex = 0;

/* =========================
   CANVAS
========================= */
const canvas = document.getElementById("board");
const ctx = canvas.getContext("2d");

/* =========================
   DRAW BOARD
========================= */
function drawBoard() {
  ctx.clearRect(0,0,400,400);

  for (let y=0;y<GRID;y++) {
    for (let x=0;x<GRID;x++) {
      if (board[y][x] === 1) ctx.fillStyle = "#f4a261";
      else if (board[y][x] === 2) ctx.fillStyle = "#90dbf4";
      else ctx.fillStyle = "#ffffff";

      ctx.fillRect(x*CELL, y*CELL, CELL, CELL);
      ctx.strokeRect(x*CELL, y*CELL, CELL, CELL);

      if (board[y][x] === 2) {
        ctx.fillStyle = "black";
        ctx.fillText("FINISH", x*CELL+18, y*CELL+45);
      }
    }
  }

  drawToken();
}

/* =========================
   DRAW TOKEN
========================= */
function drawToken() {
  let pos;
  if (mode === "outer") pos = outerPath[outerIndex];
  else if (mode === "inner") pos = innerPath[innerIndex];
  else pos = FINISH;

  ctx.beginPath();
  ctx.fillStyle = "blue";
  ctx.arc(
    pos.x*CELL + CELL/2,
    pos.y*CELL + CELL/2,
    14,
    0,
    Math.PI*2
  );
  ctx.fill();
}

/* =========================
   MOVE TOKEN
========================= */
function moveToken() {

  if (mode === "outer") {
    outerIndex = (outerIndex + 1) % outerPath.length;

    const pos = outerPath[outerIndex];

    // Check inner entry
    if (pos.x === INNER_ENTRY.x && pos.y === INNER_ENTRY.y) {
      mode = "inner";
      innerIndex = 0;
    }
  }

  else if (mode === "inner") {
    innerIndex++;

    // Exact finish entry rule
    if (innerIndex === innerPath.length) {
      mode = "finish";
    }
  }

  drawBoard();
}

drawBoard();
</script>

</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Marble Ludo</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background: #f2f2f2;
    }
    canvas {
      background: white;
      border: 2px solid black;
      margin-top: 15px;
    }
    button {
      margin-top: 10px;
      padding: 8px 16px;
      font-size: 16px;
    }
    #info {
      margin-top: 8px;
      font-weight: bold;
    }
  </style>
</head>
<body>

<h2>Marble Ludo</h2>
<button onclick="playTurn()">Draw Marbles</button>
<div id="info"></div>

<canvas id="board" width="400" height="400"></canvas>

<script>
/* =========================
   CONFIG
========================= */
const GRID = 5;
const CELL = 80;
const MAX_EXTRA_DRAWS = 2;

/* =========================
   BOARD
========================= */
const board = [
  [0,0,1,0,0],
  [0,0,0,0,0],
  [1,0,2,0,1],
  [0,0,0,0,0],
  [0,0,1,0,0]
];

/* =========================
   PATHS
========================= */
const outerPath = [
  {x:0,y:0},{x:1,y:0},{x:2,y:0},{x:3,y:0},{x:4,y:0},
  {x:4,y:1},{x:4,y:2},{x:4,y:3},{x:4,y:4},
  {x:3,y:4},{x:2,y:4},{x:1,y:4},{x:0,y:4},
  {x:0,y:3},{x:0,y:2},{x:0,y:1}
];

const innerPath = [
  {x:2,y:3},
  {x:3,y:2},
  {x:2,y:1},
  {x:1,y:2}
];

const START = {x:2,y:4};
const INNER_ENTRY = {x:1,y:4};
const FINISH = {x:2,y:2};

/* =========================
   STATE
========================= */
let mode = "outer"; // outer | inner | finish
let outerIndex = outerPath.findIndex(p => p.x===START.x && p.y===START.y);
let innerIndex = 0;
let extraDrawsUsed = 0;

const canvas = document.getElementById("board");
const ctx = canvas.getContext("2d");
const info = document.getElementById("info");

/* =========================
   DRAW
========================= */
function drawBoard() {
  ctx.clearRect(0,0,400,400);

  for (let y=0;y<GRID;y++) {
    for (let x=0;x<GRID;x++) {
      if (board[y][x] === 1) ctx.fillStyle = "#f4a261";
      else if (board[y][x] === 2) ctx.fillStyle = "#90dbf4";
      else ctx.fillStyle = "#fff";

      ctx.fillRect(x*CELL,y*CELL,CELL,CELL);
      ctx.strokeRect(x*CELL,y*CELL,CELL,CELL);

      if (board[y][x] === 2) {
        ctx.fillStyle = "black";
        ctx.fillText("FINISH", x*CELL+18, y*CELL+45);
      }
    }
  }

  let pos;
  if (mode === "outer") pos = outerPath[outerIndex];
  else if (mode === "inner") pos = innerPath[innerIndex];
  else pos = FINISH;

  ctx.beginPath();
  ctx.fillStyle = "blue";
  ctx.arc(pos.x*CELL+CELL/2, pos.y*CELL+CELL/2, 14, 0, Math.PI*2);
  ctx.fill();
}

/* =========================
   MARBLES
========================= */
function drawMarbles() {
  let marbles = [];
  for (let i=0;i<4;i++) {
    marbles.push(Math.random()<0.5 ? "W" : "B");
  }

  const whites = marbles.filter(m=>m==="W").length;
  let steps = 0;
  let extra = false;

  if (whites === 4) { steps = 4; extra = true; }
  else if (whites === 3) steps = 1;
  else if (whites === 2) steps = 2;
  else if (whites === 1) steps = 3;
  else { // all black
    steps = (mode==="outer") ? 8 : 9;
    extra = true;
  }

  info.innerText = `Marbles: ${marbles.join(" ")} | Steps: ${steps}`;
  return {steps, extra};
}

/* =========================
   MOVE
========================= */
function moveOneStep() {
  if (mode === "outer") {
    outerIndex = (outerIndex + 1) % outerPath.length;
    const p = outerPath[outerIndex];
    if (p.x===INNER_ENTRY.x && p.y===INNER_ENTRY.y) {
      mode = "inner";
      innerIndex = 0;
    }
  }
  else if (mode === "inner") {
    innerIndex++;
    if (innerIndex === innerPath.length) {
      mode = "finish";
    }
  }
}

function moveBySteps(steps) {
  for (let i=0;i<steps;i++) {
    if (mode === "finish") break;
    moveOneStep();
  }
}

/* =========================
   TURN
========================= */
function playTurn() {
  if (mode === "finish") return;

  const result = drawMarbles();
  moveBySteps(result.steps);
  drawBoard();

  if (result.extra && extraDrawsUsed < MAX_EXTRA_DRAWS) {
    extraDrawsUsed++;
  } else {
    extraDrawsUsed = 0;
  }
}

drawBoard();
</script>

</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Marble Ludo â€“ Multiple Tokens</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background: #f2f2f2;
    }
    canvas {
      background: white;
      border: 2px solid black;
      margin-top: 15px;
    }
    button {
      margin-top: 10px;
      padding: 8px 16px;
      font-size: 16px;
    }
    #info {
      margin-top: 8px;
      font-weight: bold;
    }
  </style>
</head>
<body>

<h2>Marble Ludo â€“ Multiple Tokens</h2>
<button onclick="playTurn()">Draw Marbles</button>
<div id="info">Click a token to select</div>

<canvas id="board" width="400" height="400"></canvas>

<script>
/* =========================
   CONFIG
========================= */
const GRID = 5;
const CELL = 80;
const MAX_EXTRA_DRAWS = 2;

/* =========================
   BOARD
========================= */
const board = [
  [0,0,1,0,0],
  [0,0,0,0,0],
  [1,0,2,0,1],
  [0,0,0,0,0],
  [0,0,1,0,0]
];

/* =========================
   PATHS
========================= */
const outerPath = [
  {x:0,y:0},{x:1,y:0},{x:2,y:0},{x:3,y:0},{x:4,y:0},
  {x:4,y:1},{x:4,y:2},{x:4,y:3},{x:4,y:4},
  {x:3,y:4},{x:2,y:4},{x:1,y:4},{x:0,y:4},
  {x:0,y:3},{x:0,y:2},{x:0,y:1}
];

const innerPath = [
  {x:2,y:3},
  {x:3,y:2},
  {x:2,y:1},
  {x:1,y:2}
];

const START = {x:2,y:4};
const INNER_ENTRY = {x:1,y:4};
const FINISH = {x:2,y:2};

/* =========================
   TOKEN STATE (4 TOKENS)
========================= */
const tokens = Array.from({length:4}, () => ({
  mode: "outer",      // outer | inner | finish
  outerIndex: outerPath.findIndex(p => p.x===START.x && p.y===START.y),
  innerIndex: 0
}));

let selectedToken = 0;
let extraDrawsUsed = 0;

/* =========================
   CANVAS
========================= */
const canvas = document.getElementById("board");
const ctx = canvas.getContext("2d");
const info = document.getElementById("info");

/* =========================
   DRAW BOARD
========================= */
function drawBoard() {
  ctx.clearRect(0,0,400,400);

  for (let y=0;y<GRID;y++) {
    for (let x=0;x<GRID;x++) {
      if (board[y][x] === 1) ctx.fillStyle = "#f4a261";
      else if (board[y][x] === 2) ctx.fillStyle = "#90dbf4";
      else ctx.fillStyle = "#fff";

      ctx.fillRect(x*CELL,y*CELL,CELL,CELL);
      ctx.strokeRect(x*CELL,y*CELL,CELL,CELL);

      if (board[y][x] === 2) {
        ctx.fillStyle = "black";
        ctx.fillText("FINISH", x*CELL+18, y*CELL+45);
      }
    }
  }

  tokens.forEach((t, i) => {
    let pos;
    if (t.mode === "outer") pos = outerPath[t.outerIndex];
    else if (t.mode === "inner") pos = innerPath[t.innerIndex];
    else pos = FINISH;

    ctx.beginPath();
    ctx.fillStyle = (i === selectedToken) ? "red" : "blue";
    ctx.arc(pos.x*CELL+CELL/2, pos.y*CELL+CELL/2, 12, 0, Math.PI*2);
    ctx.fill();
  });
}

/* =========================
   MARBLES
========================= */
function drawMarbles() {
  let marbles = [];
  for (let i=0;i<4;i++) marbles.push(Math.random()<0.5 ? "W":"B");

  const whites = marbles.filter(m=>m==="W").length;
  let steps, extra=false;

  if (whites===4) { steps=4; extra=true; }
  else if (whites===3) steps=1;
  else if (whites===2) steps=2;
  else if (whites===1) steps=3;
  else { steps = (tokens[selectedToken].mode==="outer") ? 8 : 9; extra=true; }

  info.innerText = `Token ${selectedToken+1} | Marbles: ${marbles.join(" ")} | Steps: ${steps}`;
  return {steps, extra};
}

/* =========================
   MOVE LOGIC
========================= */
function moveOneStep(t) {
  if (t.mode === "outer") {
    t.outerIndex = (t.outerIndex + 1) % outerPath.length;
    const p = outerPath[t.outerIndex];
    if (p.x===INNER_ENTRY.x && p.y===INNER_ENTRY.y) {
      t.mode = "inner";
      t.innerIndex = 0;
    }
  } else if (t.mode === "inner") {
    t.innerIndex++;
    if (t.innerIndex === innerPath.length) {
      t.mode = "finish";
    }
  }
}

function moveBySteps(steps) {
  const t = tokens[selectedToken];
  for (let i=0;i<steps;i++) {
    if (t.mode==="finish") break;
    moveOneStep(t);
  }
}

/* =========================
   TURN
========================= */
function playTurn() {
  const result = drawMarbles();
  moveBySteps(result.steps);
  drawBoard();

  if (result.extra && extraDrawsUsed < MAX_EXTRA_DRAWS) {
    extraDrawsUsed++;
  } else {
    extraDrawsUsed = 0;
  }
}

/* =========================
   TOKEN SELECTION
========================= */
canvas.addEventListener("click", e => {
  const r = canvas.getBoundingClientRect();
  const x = e.clientX - r.left;
  const y = e.clientY - r.top;

  tokens.forEach((t,i) => {
    let pos;
    if (t.mode==="outer") pos = outerPath[t.outerIndex];
    else if (t.mode==="inner") pos = innerPath[t.innerIndex];
    else pos = FINISH;

    const cx = pos.x*CELL+CELL/2;
    const cy = pos.y*CELL+CELL/2;
    if (Math.hypot(x-cx,y-cy) < 14) {
      selectedToken = i;
      info.innerText = `Selected Token ${i+1}`;
      drawBoard();
    }
  });
});

drawBoard();
</script>

</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Marble Ludo â€“ Capture Logic</title>
<style>
body{font-family:Arial;text-align:center;background:#f2f2f2}
canvas{background:white;border:2px solid black;margin-top:15px}
button{margin-top:10px;padding:8px 16px;font-size:16px}
#info{margin-top:8px;font-weight:bold}
</style>
</head>
<body>

<h2>Marble Ludo â€“ Capture Logic</h2>
<button onclick="playTurn()">Draw Marbles</button>
<div id="info"></div>

<canvas id="board" width="400" height="400"></canvas>

<script>
/* ===== CONFIG ===== */
const GRID=5, CELL=80, MAX_EXTRA_DRAWS=2;

/* ===== BOARD ===== */
const board=[
 [0,0,1,0,0],
 [0,0,0,0,0],
 [1,0,2,0,1],
 [0,0,0,0,0],
 [0,0,1,0,0]
];

/* ===== PATHS ===== */
const outerPath=[
 {x:0,y:0},{x:1,y:0},{x:2,y:0},{x:3,y:0},{x:4,y:0},
 {x:4,y:1},{x:4,y:2},{x:4,y:3},{x:4,y:4},
 {x:3,y:4},{x:2,y:4},{x:1,y:4},{x:0,y:4},
 {x:0,y:3},{x:0,y:2},{x:0,y:1}
];

const innerPath=[
 {x:2,y:3},{x:3,y:2},{x:2,y:1},{x:1,y:2}
];

const START={x:2,y:4}, INNER_ENTRY={x:1,y:4}, FINISH={x:2,y:2};

/* ===== PLAYERS ===== */
const players=[
 {color:"blue", tokens:[]},
 {color:"green", tokens:[]}
];

players.forEach(p=>{
 for(let i=0;i<4;i++){
  p.tokens.push({
   mode:"outer",
   outerIndex:outerPath.findIndex(q=>q.x===START.x&&q.y===START.y),
   innerIndex:0
  });
 }
});

let currentPlayer=0;
let selectedToken=0;
let extraDrawsUsed=0;

/* ===== CANVAS ===== */
const canvas=document.getElementById("board");
const ctx=canvas.getContext("2d");
const info=document.getElementById("info");

/* ===== DRAW ===== */
function drawBoard(){
 ctx.clearRect(0,0,400,400);
 for(let y=0;y<GRID;y++)for(let x=0;x<GRID;x++){
  ctx.fillStyle=board[y][x]==1?"#f4a261":board[y][x]==2?"#90dbf4":"#fff";
  ctx.fillRect(x*CELL,y*CELL,CELL,CELL);
  ctx.strokeRect(x*CELL,y*CELL,CELL,CELL);
  if(board[y][x]==2)ctx.fillText("FINISH",x*CELL+18,y*CELL+45);
 }
 players.forEach((p,pi)=>{
  p.tokens.forEach((t,i)=>{
   let pos=t.mode==="outer"?outerPath[t.outerIndex]:
           t.mode==="inner"?innerPath[t.innerIndex]:FINISH;
   ctx.beginPath();
   ctx.fillStyle=(pi===currentPlayer && i===selectedToken)? "red":p.color;
   ctx.arc(pos.x*CELL+CELL/2,pos.y*CELL+CELL/2,12,0,Math.PI*2);
   ctx.fill();
  });
 });
}

/* ===== MARBLES ===== */
function drawMarbles(){
 let m=[]; for(let i=0;i<4;i++)m.push(Math.random()<0.5?"W":"B");
 let w=m.filter(x=>x==="W").length;
 let steps,extra=false;
 if(w===4){steps=4;extra=true}
 else if(w===3)steps=1;
 else if(w===2)steps=2;
 else if(w===1)steps=3;
 else{steps=(players[currentPlayer].tokens[selectedToken].mode==="outer")?8:9;extra=true}
 info.innerText=`P${currentPlayer+1} | ${m.join(" ")} â†’ ${steps}`;
 return{steps,extra};
}

/* ===== MOVE ===== */
function moveOneStep(t){
 if(t.mode==="outer"){
  t.outerIndex=(t.outerIndex+1)%outerPath.length;
  let p=outerPath[t.outerIndex];
  if(p.x===INNER_ENTRY.x&&p.y===INNER_ENTRY.y){t.mode="inner";t.innerIndex=0}
 }else if(t.mode==="inner"){
  t.innerIndex++;
  if(t.innerIndex===innerPath.length)t.mode="finish";
 }
}

/* ===== CAPTURE ===== */
function checkCapture(){
 const attacker=players[currentPlayer];
 const victim=players[1-currentPlayer];
 const t=attacker.tokens[selectedToken];
 if(t.mode!=="outer")return false;
 const pos=outerPath[t.outerIndex];
 if(board[pos.y][pos.x]===1)return false; // safe square

 for(let vt of victim.tokens){
  if(vt.mode==="outer" && outerPath[vt.outerIndex].x===pos.x && outerPath[vt.outerIndex].y===pos.y){
   vt.mode="outer";
   vt.outerIndex=outerPath.findIndex(q=>q.x===START.x&&q.y===START.y);
   vt.innerIndex=0;
   info.innerText+=" | CAPTURE!";
   return true;
  }
 }
 return false;
}

function moveBySteps(steps){
 let t=players[currentPlayer].tokens[selectedToken];
 for(let i=0;i<steps;i++){
  if(t.mode==="finish")break;
  moveOneStep(t);
 }
}

/* ===== TURN ===== */
function playTurn(){
 let r=drawMarbles();
 moveBySteps(r.steps);
 let captured=checkCapture();
 drawBoard();

 if((r.extra||captured)&&extraDrawsUsed<MAX_EXTRA_DRAWS){
  extraDrawsUsed++;
 }else{
  extraDrawsUsed=0;
  currentPlayer=1-currentPlayer;
 }
}

/* ===== TOKEN SELECT ===== */
canvas.addEventListener("click",e=>{
 let r=canvas.getBoundingClientRect(),x=e.clientX-r.left,y=e.clientY-r.top;
 players[currentPlayer].tokens.forEach((t,i)=>{
  let p=t.mode==="outer"?outerPath[t.outerIndex]:
        t.mode==="inner"?innerPath[t.innerIndex]:FINISH;
  if(Math.hypot(x-(p.x*CELL+CELL/2),y-(p.y*CELL+CELL/2))<14){
   selectedToken=i; drawBoard();
  }
 });
});

drawBoard();
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Marble Ludo â€“ Finish Extra Draw</title>
<style>
body{font-family:Arial;text-align:center;background:#f2f2f2}
canvas{background:white;border:2px solid black;margin-top:15px}
button{margin-top:10px;padding:8px 16px;font-size:16px}
#info{margin-top:8px;font-weight:bold}
</style>
</head>
<body>

<h2>Marble Ludo</h2>
<button onclick="playTurn()">Draw Marbles</button>
<div id="info"></div>

<canvas id="board" width="400" height="400"></canvas>

<script>
/* ===== CONFIG ===== */
const GRID=5, CELL=80, MAX_EXTRA_DRAWS=2;

/* ===== BOARD ===== */
const board=[
 [0,0,1,0,0],
 [0,0,0,0,0],
 [1,0,2,0,1],
 [0,0,0,0,0],
 [0,0,1,0,0]
];

/* ===== PATHS ===== */
const outerPath=[
 {x:0,y:0},{x:1,y:0},{x:2,y:0},{x:3,y:0},{x:4,y:0},
 {x:4,y:1},{x:4,y:2},{x:4,y:3},{x:4,y:4},
 {x:3,y:4},{x:2,y:4},{x:1,y:4},{x:0,y:4},
 {x:0,y:3},{x:0,y:2},{x:0,y:1}
];

const innerPath=[
 {x:2,y:3},{x:3,y:2},{x:2,y:1},{x:1,y:2}
];

const START={x:2,y:4}, INNER_ENTRY={x:1,y:4}, FINISH={x:2,y:2};

/* ===== PLAYERS ===== */
const players=[
 {color:"blue", tokens:[]},
 {color:"green", tokens:[]}
];

players.forEach(p=>{
 for(let i=0;i<4;i++){
  p.tokens.push({
   mode:"outer",
   outerIndex:outerPath.findIndex(q=>q.x===START.x&&q.y===START.y),
   innerIndex:0,
   finished:false
  });
 }
});

let currentPlayer=0;
let selectedToken=0;
let extraDrawsUsed=0;

/* ===== CANVAS ===== */
const canvas=document.getElementById("board");
const ctx=canvas.getContext("2d");
const info=document.getElementById("info");

/* ===== DRAW ===== */
function drawBoard(){
 ctx.clearRect(0,0,400,400);
 for(let y=0;y<GRID;y++)for(let x=0;x<GRID;x++){
  ctx.fillStyle=board[y][x]==1?"#f4a261":board[y][x]==2?"#90dbf4":"#fff";
  ctx.fillRect(x*CELL,y*CELL,CELL,CELL);
  ctx.strokeRect(x*CELL,y*CELL,CELL,CELL);
  if(board[y][x]==2)ctx.fillText("FINISH",x*CELL+18,y*CELL+45);
 }
 players.forEach((p,pi)=>{
  p.tokens.forEach((t,i)=>{
   if(t.finished) return;
   let pos=t.mode==="outer"?outerPath[t.outerIndex]:
           t.mode==="inner"?innerPath[t.innerIndex]:FINISH;
   ctx.beginPath();
   ctx.fillStyle=(pi===currentPlayer && i===selectedToken)?"red":p.color;
   ctx.arc(pos.x*CELL+CELL/2,pos.y*CELL+CELL/2,12,0,Math.PI*2);
   ctx.fill();
  });
 });
}

/* ===== MARBLES ===== */
function drawMarbles(){
 let m=[]; for(let i=0;i<4;i++)m.push(Math.random()<0.5?"W":"B");
 let w=m.filter(x=>x==="W").length;
 let steps,extra=false;
 if(w===4){steps=4;extra=true}
 else if(w===3)steps=1;
 else if(w===2)steps=2;
 else if(w===1)steps=3;
 else{steps=(players[currentPlayer].tokens[selectedToken].mode==="outer")?8:9;extra=true}
 info.innerText=`P${currentPlayer+1} | ${m.join(" ")} â†’ ${steps}`;
 return{steps,extra};
}

/* ===== MOVE ===== */
function moveOneStep(t){
 if(t.mode==="outer"){
  t.outerIndex=(t.outerIndex+1)%outerPath.length;
  let p=outerPath[t.outerIndex];
  if(p.x===INNER_ENTRY.x&&p.y===INNER_ENTRY.y){t.mode="inner";t.innerIndex=0}
 }else if(t.mode==="inner"){
  t.innerIndex++;
  if(t.innerIndex===innerPath.length){
   t.finished=true;
   info.innerText+=" | FINISHED!";
   return "finished";
  }
 }
 return null;
}

/* ===== CAPTURE ===== */
function checkCapture(){
 const atk=players[currentPlayer];
 const def=players[1-currentPlayer];
 const t=atk.tokens[selectedToken];
 if(t.mode!=="outer")return false;
 const pos=outerPath[t.outerIndex];
 if(board[pos.y][pos.x]===1)return false;
 for(let vt of def.tokens){
  if(!vt.finished && vt.mode==="outer"){
   let p=outerPath[vt.outerIndex];
   if(p.x===pos.x&&p.y===pos.y){
    vt.mode="outer";
    vt.outerIndex=outerPath.findIndex(q=>q.x===START.x&&q.y===START.y);
    vt.innerIndex=0;
    return true;
   }
  }
 }
 return false;
}

/* ===== TURN ===== */
function playTurn(){
 const r=drawMarbles();
 let t=players[currentPlayer].tokens[selectedToken];
 let finishedThisMove=false;

 for(let i=0;i<r.steps;i++){
  if(t.finished)break;
  let res=moveOneStep(t);
  if(res==="finished"){ finishedThisMove=true; break; }
 }

 let captured=checkCapture();
 drawBoard();

 if((r.extra||captured||finishedThisMove) && extraDrawsUsed<MAX_EXTRA_DRAWS){
  extraDrawsUsed++;
 }else{
  extraDrawsUsed=0;
  currentPlayer=1-currentPlayer;
 }
}

/* ===== TOKEN SELECT ===== */
canvas.addEventListener("click",e=>{
 let r=canvas.getBoundingClientRect(),x=e.clientX-r.left,y=e.clientY-r.top;
 players[currentPlayer].tokens.forEach((t,i)=>{
  if(t.finished)return;
  let p=t.mode==="outer"?outerPath[t.outerIndex]:
        t.mode==="inner"?innerPath[t.innerIndex]:FINISH;
  if(Math.hypot(x-(p.x*CELL+CELL/2),y-(p.y*CELL+CELL/2))<14){
   selectedToken=i; drawBoard();
  }
 });
});

drawBoard();
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Marble Ludo â€“ Finish Extra Draw</title>
<style>
body{font-family:Arial;text-align:center;background:#f2f2f2}
canvas{background:white;border:2px solid black;margin-top:15px}
button{margin-top:10px;padding:8px 16px;font-size:16px}
#info{margin-top:8px;font-weight:bold}
</style>
</head>
<body>

<h2>Marble Ludo</h2>
<button onclick="playTurn()">Draw Marbles</button>
<div id="info"></div>

<canvas id="board" width="400" height="400"></canvas>

<script>
/* ===== CONFIG ===== */
const GRID=5, CELL=80, MAX_EXTRA_DRAWS=2;

/* ===== BOARD ===== */
const board=[
 [0,0,1,0,0],
 [0,0,0,0,0],
 [1,0,2,0,1],
 [0,0,0,0,0],
 [0,0,1,0,0]
];

/* ===== PATHS ===== */
const outerPath=[
 {x:0,y:0},{x:1,y:0},{x:2,y:0},{x:3,y:0},{x:4,y:0},
 {x:4,y:1},{x:4,y:2},{x:4,y:3},{x:4,y:4},
 {x:3,y:4},{x:2,y:4},{x:1,y:4},{x:0,y:4},
 {x:0,y:3},{x:0,y:2},{x:0,y:1}
];

const innerPath=[
 {x:2,y:3},{x:3,y:2},{x:2,y:1},{x:1,y:2}
];

const START={x:2,y:4}, INNER_ENTRY={x:1,y:4}, FINISH={x:2,y:2};

/* ===== PLAYERS ===== */
const players=[
 {color:"blue", tokens:[]},
 {color:"green", tokens:[]}
];

players.forEach(p=>{
 for(let i=0;i<4;i++){
  p.tokens.push({
   mode:"outer",
   outerIndex:outerPath.findIndex(q=>q.x===START.x&&q.y===START.y),
   innerIndex:0,
   finished:false
  });
 }
});

let currentPlayer=0;
let selectedToken=0;
let extraDrawsUsed=0;

/* ===== CANVAS ===== */
const canvas=document.getElementById("board");
const ctx=canvas.getContext("2d");
const info=document.getElementById("info");

/* ===== DRAW ===== */
function drawBoard(){
 ctx.clearRect(0,0,400,400);
 for(let y=0;y<GRID;y++)for(let x=0;x<GRID;x++){
  ctx.fillStyle=board[y][x]==1?"#f4a261":board[y][x]==2?"#90dbf4":"#fff";
  ctx.fillRect(x*CELL,y*CELL,CELL,CELL);
  ctx.strokeRect(x*CELL,y*CELL,CELL,CELL);
  if(board[y][x]==2)ctx.fillText("FINISH",x*CELL+18,y*CELL+45);
 }
 players.forEach((p,pi)=>{
  p.tokens.forEach((t,i)=>{
   if(t.finished) return;
   let pos=t.mode==="outer"?outerPath[t.outerIndex]:
           t.mode==="inner"?innerPath[t.innerIndex]:FINISH;
   ctx.beginPath();
   ctx.fillStyle=(pi===currentPlayer && i===selectedToken)?"red":p.color;
   ctx.arc(pos.x*CELL+CELL/2,pos.y*CELL+CELL/2,12,0,Math.PI*2);
   ctx.fill();
  });
 });
}

/* ===== MARBLES ===== */
function drawMarbles(){
 let m=[]; for(let i=0;i<4;i++)m.push(Math.random()<0.5?"W":"B");
 let w=m.filter(x=>x==="W").length;
 let steps,extra=false;
 if(w===4){steps=4;extra=true}
 else if(w===3)steps=1;
 else if(w===2)steps=2;
 else if(w===1)steps=3;
 else{steps=(players[currentPlayer].tokens[selectedToken].mode==="outer")?8:9;extra=true}
 info.innerText=`P${currentPlayer+1} | ${m.join(" ")} â†’ ${steps}`;
 return{steps,extra};
}

/* ===== MOVE ===== */
function moveOneStep(t){
 if(t.mode==="outer"){
  t.outerIndex=(t.outerIndex+1)%outerPath.length;
  let p=outerPath[t.outerIndex];
  if(p.x===INNER_ENTRY.x&&p.y===INNER_ENTRY.y){t.mode="inner";t.innerIndex=0}
 }else if(t.mode==="inner"){
  t.innerIndex++;
  if(t.innerIndex===innerPath.length){
   t.finished=true;
   info.innerText+=" | FINISHED!";
   return "finished";
  }
 }
 return null;
}

/* ===== CAPTURE ===== */
function checkCapture(){
 const atk=players[currentPlayer];
 const def=players[1-currentPlayer];
 const t=atk.tokens[selectedToken];
 if(t.mode!=="outer")return false;
 const pos=outerPath[t.outerIndex];
 if(board[pos.y][pos.x]===1)return false;
 for(let vt of def.tokens){
  if(!vt.finished && vt.mode==="outer"){
   let p=outerPath[vt.outerIndex];
   if(p.x===pos.x&&p.y===pos.y){
    vt.mode="outer";
    vt.outerIndex=outerPath.findIndex(q=>q.x===START.x&&q.y===START.y);
    vt.innerIndex=0;
    return true;
   }
  }
 }
 return false;
}

/* ===== TURN ===== */
function playTurn(){
 const r=drawMarbles();
 let t=players[currentPlayer].tokens[selectedToken];
 let finishedThisMove=false;

 for(let i=0;i<r.steps;i++){
  if(t.finished)break;
  let res=moveOneStep(t);
  if(res==="finished"){ finishedThisMove=true; break; }
 }

 let captured=checkCapture();
 drawBoard();

 if((r.extra||captured||finishedThisMove) && extraDrawsUsed<MAX_EXTRA_DRAWS){
  extraDrawsUsed++;
 }else{
  extraDrawsUsed=0;
  currentPlayer=1-currentPlayer;
 }
}

/* ===== TOKEN SELECT ===== */
canvas.addEventListener("click",e=>{
 let r=canvas.getBoundingClientRect(),x=e.clientX-r.left,y=e.clientY-r.top;
 players[currentPlayer].tokens.forEach((t,i)=>{
  if(t.finished)return;
  let p=t.mode==="outer"?outerPath[t.outerIndex]:
        t.mode==="inner"?innerPath[t.innerIndex]:FINISH;
  if(Math.hypot(x-(p.x*CELL+CELL/2),y-(p.y*CELL+CELL/2))<14){
   selectedToken=i; drawBoard();
  }
 });
});

drawBoard();
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Marble Ludo â€“ Win Condition</title>
<style>
body{font-family:Arial;text-align:center;background:#f2f2f2}
canvas{background:white;border:2px solid black;margin-top:15px}
button{margin-top:10px;padding:8px 16px;font-size:16px}
#info{margin-top:8px;font-weight:bold}
</style>
</head>
<body>

<h2>Marble Ludo</h2>
<button id="drawBtn" onclick="playTurn()">Draw Marbles</button>
<div id="info"></div>

<canvas id="board" width="400" height="400"></canvas>

<script>
/* ===== CONFIG ===== */
const GRID=5, CELL=80, MAX_EXTRA_DRAWS=2;

/* ===== BOARD ===== */
const board=[
 [0,0,1,0,0],
 [0,0,0,0,0],
 [1,0,2,0,1],
 [0,0,0,0,0],
 [0,0,1,0,0]
];

/* ===== PATHS ===== */
const outerPath=[
 {x:0,y:0},{x:1,y:0},{x:2,y:0},{x:3,y:0},{x:4,y:0},
 {x:4,y:1},{x:4,y:2},{x:4,y:3},{x:4,y:4},
 {x:3,y:4},{x:2,y:4},{x:1,y:4},{x:0,y:4},
 {x:0,y:3},{x:0,y:2},{x:0,y:1}
];

const innerPath=[
 {x:2,y:3},{x:3,y:2},{x:2,y:1},{x:1,y:2}
];

const START={x:2,y:4}, INNER_ENTRY={x:1,y:4}, FINISH={x:2,y:2};

/* ===== PLAYERS ===== */
const players=[
 {color:"blue", tokens:[]},
 {color:"green", tokens:[]}
];

players.forEach(p=>{
 for(let i=0;i<4;i++){
  p.tokens.push({
   mode:"outer",
   outerIndex:outerPath.findIndex(q=>q.x===START.x&&q.y===START.y),
   innerIndex:0,
   finished:false
  });
 }
});

let currentPlayer=0;
let selectedToken=0;
let extraDrawsUsed=0;
let gameOver=false;

/* ===== CANVAS ===== */
const canvas=document.getElementById("board");
const ctx=canvas.getContext("2d");
const info=document.getElementById("info");
const drawBtn=document.getElementById("drawBtn");

/* ===== DRAW ===== */
function drawBoard(){
 ctx.clearRect(0,0,400,400);
 for(let y=0;y<GRID;y++)for(let x=0;x<GRID;x++){
  ctx.fillStyle=board[y][x]==1?"#f4a261":board[y][x]==2?"#90dbf4":"#fff";
  ctx.fillRect(x*CELL,y*CELL,CELL,CELL);
  ctx.strokeRect(x*CELL,y*CELL,CELL,CELL);
  if(board[y][x]==2)ctx.fillText("FINISH",x*CELL+18,y*CELL+45);
 }
 players.forEach((p,pi)=>{
  p.tokens.forEach((t,i)=>{
   if(t.finished) return;
   let pos=t.mode==="outer"?outerPath[t.outerIndex]:
           t.mode==="inner"?innerPath[t.innerIndex]:FINISH;
   ctx.beginPath();
   ctx.fillStyle=(pi===currentPlayer && i===selectedToken)?"red":p.color;
   ctx.arc(pos.x*CELL+CELL/2,pos.y*CELL+CELL/2,12,0,Math.PI*2);
   ctx.fill();
  });
 });
}

/* ===== MARBLES ===== */
function drawMarbles(){
 let m=[]; for(let i=0;i<4;i++)m.push(Math.random()<0.5?"W":"B");
 let w=m.filter(x=>x==="W").length;
 let steps,extra=false;
 if(w===4){steps=4;extra=true}
 else if(w===3)steps=1;
 else if(w===2)steps=2;
 else if(w===1)steps=3;
 else{steps=(players[currentPlayer].tokens[selectedToken].mode==="outer")?8:9;extra=true}
 info.innerText=`P${currentPlayer+1} | ${m.join(" ")} â†’ ${steps}`;
 return{steps,extra};
}

/* ===== MOVE ===== */
function moveOneStep(t){
 if(t.mode==="outer"){
  t.outerIndex=(t.outerIndex+1)%outerPath.length;
  let p=outerPath[t.outerIndex];
  if(p.x===INNER_ENTRY.x&&p.y===INNER_ENTRY.y){t.mode="inner";t.innerIndex=0}
 }else if(t.mode==="inner"){
  t.innerIndex++;
  if(t.innerIndex===innerPath.length){
   t.finished=true;
   return "finished";
  }
 }
 return null;
}

/* ===== CAPTURE ===== */
function checkCapture(){
 const atk=players[currentPlayer];
 const def=players[1-currentPlayer];
 const t=atk.tokens[selectedToken];
 if(t.mode!=="outer")return false;
 const pos=outerPath[t.outerIndex];
 if(board[pos.y][pos.x]===1)return false;
 for(let vt of def.tokens){
  if(!vt.finished && vt.mode==="outer"){
   let p=outerPath[vt.outerIndex];
   if(p.x===pos.x&&p.y===pos.y){
    vt.mode="outer";
    vt.outerIndex=outerPath.findIndex(q=>q.x===START.x&&q.y===START.y);
    vt.innerIndex=0;
    return true;
   }
  }
 }
 return false;
}

/* ===== WIN CHECK ===== */
function checkWin(){
 const finishedCount=players[currentPlayer].tokens.filter(t=>t.finished).length;
 if(finishedCount===4){
  info.innerText=`ðŸŽ‰ Player ${currentPlayer+1} WINS THE GAME!`;
  gameOver=true;
  drawBtn.disabled=true;
 }
}

/* ===== TURN ===== */
function playTurn(){
 if(gameOver) return;

 const r=drawMarbles();
 const t=players[currentPlayer].tokens[selectedToken];
 let finishedThisMove=false;

 for(let i=0;i<r.steps;i++){
  if(t.finished)break;
  if(moveOneStep(t)==="finished"){finishedThisMove=true;break;}
 }

 const captured=checkCapture();
 drawBoard();
 checkWin();
 if(gameOver) return;

 if((r.extra||captured||finishedThisMove) && extraDrawsUsed<MAX_EXTRA_DRAWS){
  extraDrawsUsed++;
 }else{
  extraDrawsUsed=0;
  currentPlayer=1-currentPlayer;
 }
}

/* ===== TOKEN SELECT ===== */
canvas.addEventListener("click",e=>{
 if(gameOver) return;
 let r=canvas.getBoundingClientRect(),x=e.clientX-r.left,y=e.clientY-r.top;
 players[currentPlayer].tokens.forEach((t,i)=>{
  if(t.finished)return;
  let p=t.mode==="outer"?outerPath[t.outerIndex]:
        t.mode==="inner"?innerPath[t.innerIndex]:FINISH;
  if(Math.hypot(x-(p.x*CELL+CELL/2),y-(p.y*CELL+CELL/2))<14){
   selectedToken=i; drawBoard();
  }
 });
});

drawBoard();
</script>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Marble Ludo â€“ 4 Players</title>
<style>
body{font-family:Arial;text-align:center;background:#f2f2f2}
canvas{background:white;border:2px solid black;margin-top:15px}
button{margin-top:10px;padding:8px 16px;font-size:16px}
#info{margin-top:8px;font-weight:bold}
</style>
</head>
<body>

<h2>Marble Ludo â€“ 4 Players</h2>
<button id="drawBtn" onclick="playTurn()">Draw Marbles</button>
<div id="info"></div>

<canvas id="board" width="400" height="400"></canvas>

<script>
const GRID=5, CELL=80, MAX_EXTRA_DRAWS=2;

const board=[
 [0,0,1,0,0],
 [0,0,0,0,0],
 [1,0,2,0,1],
 [0,0,0,0,0],
 [0,0,1,0,0]
];

const outerPath=[
 {x:0,y:0},{x:1,y:0},{x:2,y:0},{x:3,y:0},{x:4,y:0},
 {x:4,y:1},{x:4,y:2},{x:4,y:3},{x:4,y:4},
 {x:3,y:4},{x:2,y:4},{x:1,y:4},{x:0,y:4},
 {x:0,y:3},{x:0,y:2},{x:0,y:1}
];

const innerPath=[
 {x:2,y:3},{x:3,y:2},{x:2,y:1},{x:1,y:2}
];

const FINISH={x:2,y:2};

const players=[
 {name:"P1",color:"blue",start:{x:2,y:4},tokens:[]},
 {name:"P2",color:"green",start:{x:4,y:2},tokens:[]},
 {name:"P3",color:"purple",start:{x:2,y:0},tokens:[]},
 {name:"P4",color:"orange",start:{x:0,y:2},tokens:[]}
];

players.forEach(p=>{
 const idx=outerPath.findIndex(q=>q.x===p.start.x&&q.y===p.start.y);
 for(let i=0;i<4;i++){
  p.tokens.push({mode:"outer",outerIndex:idx,innerIndex:0,finished:false});
 }
});

let currentPlayer=0, selectedToken=0, extraDrawsUsed=0, gameOver=false;

const canvas=document.getElementById("board");
const ctx=canvas.getContext("2d");
const info=document.getElementById("info");
const drawBtn=document.getElementById("drawBtn");

function drawBoard(){
 ctx.clearRect(0,0,400,400);
 for(let y=0;y<GRID;y++)for(let x=0;x<GRID;x++){
  ctx.fillStyle=board[y][x]==1?"#f4a261":board[y][x]==2?"#90dbf4":"#fff";
  ctx.fillRect(x*CELL,y*CELL,CELL,CELL);
  ctx.strokeRect(x*CELL,y*CELL,CELL,CELL);
  if(board[y][x]==2)ctx.fillText("FINISH",x*CELL+18,y*CELL+45);
 }
 players.forEach((p,pi)=>{
  p.tokens.forEach((t,i)=>{
   if(t.finished)return;
   let pos=t.mode==="outer"?outerPath[t.outerIndex]:
           t.mode==="inner"?innerPath[t.innerIndex]:FINISH;
   ctx.beginPath();
   ctx.fillStyle=(pi===currentPlayer&&i===selectedToken)?"red":p.color;
   ctx.arc(pos.x*CELL+CELL/2,pos.y*CELL+CELL/2,12,0,Math.PI*2);
   ctx.fill();
  });
 });
}

function drawMarbles(){
 let m=[], w;
 for(let i=0;i<4;i++)m.push(Math.random()<0.5?"W":"B");
 w=m.filter(x=>x==="W").length;
 let steps,extra=false;
 if(w===4){steps=4;extra=true}
 else if(w===3)steps=1;
 else if(w===2)steps=2;
 else if(w===1)steps=3;
 else{steps=(players[currentPlayer].tokens[selectedToken].mode==="outer")?8:9;extra=true}
 info.innerText=`${players[currentPlayer].name}: ${m.join(" ")} â†’ ${steps}`;
 return{steps,extra};
}

function moveOneStep(t){
 if(t.mode==="outer"){
  t.outerIndex=(t.outerIndex+1)%outerPath.length;
  let p=outerPath[t.outerIndex];
  if(board[p.y][p.x]===1 && p.x===2 && p.y!==2){
   t.mode="inner"; t.innerIndex=0;
  }
 }else if(t.mode==="inner"){
  t.innerIndex++;
  if(t.innerIndex===innerPath.length){t.finished=true; return "finish";}
 }
}

function checkCapture(){
 let atk=players[currentPlayer];
 let pos=outerPath[atk.tokens[selectedToken].outerIndex];
 if(board[pos.y][pos.x]===1)return false;
 for(let pi=0;pi<players.length;pi++){
  if(pi===currentPlayer)continue;
  for(let t of players[pi].tokens){
   if(!t.finished && t.mode==="outer"){
    let p=outerPath[t.outerIndex];
    if(p.x===pos.x&&p.y===pos.y){
     t.outerIndex=outerPath.findIndex(q=>q.x===players[pi].start.x&&q.y===players[pi].start.y);
     t.mode="outer"; t.innerIndex=0;
     return true;
    }
   }
  }
 }
 return false;
}

function checkWin(){
 if(players[currentPlayer].tokens.every(t=>t.finished)){
  info.innerText=`ðŸŽ‰ ${players[currentPlayer].name} WINS!`;
  drawBtn.disabled=true; gameOver=true;
 }
}

function playTurn(){
 if(gameOver)return;
 let r=drawMarbles(), t=players[currentPlayer].tokens[selectedToken], finished=false;
 for(let i=0;i<r.steps;i++){
  if(t.finished)break;
  if(moveOneStep(t)==="finish"){finished=true;break;}
 }
 let captured=checkCapture();
 drawBoard(); checkWin();
 if(gameOver)return;
 if((r.extra||captured||finished)&&extraDrawsUsed<MAX_EXTRA_DRAWS){
  extraDrawsUsed++;
 }else{
  extraDrawsUsed=0;
  currentPlayer=(currentPlayer+1)%4;
 }
}

canvas.addEventListener("click",e=>{
 if(gameOver)return;
 let r=canvas.getBoundingClientRect(),x=e.clientX-r.left,y=e.clientY-r.top;
 players[currentPlayer].tokens.forEach((t,i)=>{
  if(t.finished)return;
  let p=t.mode==="outer"?outerPath[t.outerIndex]:
        t.mode==="inner"?innerPath[t.innerIndex]:FINISH;
  if(Math.hypot(x-(p.x*CELL+CELL/2),y-(p.y*CELL+CELL/2))<14){
   selectedToken=i; drawBoard();
  }
 });
});

drawBoard();
</script>
</body>
</html>
