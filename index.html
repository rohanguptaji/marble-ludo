<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Marble Ludo – Stable v1.2</title>

<style>
body{
  font-family:Arial, sans-serif;
  background:#f2f2f2;
  display:flex;
  justify-content:center;
}
#game{
  position:relative;
  width:520px;
}
canvas{
  background:#fff;
  border:2px solid #000;
  margin:60px auto;
  display:block;
}
button{
  position:absolute;
  top:0;
  left:50%;
  transform:translateX(-50%);
  padding:8px 16px;
  font-size:16px;
}
.playerBox{
  position:absolute;
  width:120px;
  padding:6px;
  border:2px solid #999;
  background:#fff;
  text-align:center;
  font-size:14px;
}
.playerBox.active{
  border-color:#000;
  font-weight:bold;
}
.marbles{
  display:grid;
  grid-template-columns:repeat(2,1fr);
  gap:6px;
  justify-items:center;
  margin-top:6px;
}
.marble{
  width:18px;
  height:18px;
  border-radius:50%;
  border:1px solid #333;
}
.white{background:#f5f5f5;}
.black{background:#222;}
</style>
</head>

<body>
<div id="game">

<button onclick="playTurn()">Draw Marbles</button>

<div id="p0" class="playerBox" style="bottom:0;left:200px;color:#1f4fd8">
P1<br>Blue<div class="marbles"></div>
</div>

<div id="p1" class="playerBox" style="right:0;top:200px;color:#1e8f3e">
P2<br>Green<div class="marbles"></div>
</div>

<div id="p2" class="playerBox" style="top:0;left:200px;color:#6a1fb0">
P3<br>Purple<div class="marbles"></div>
</div>

<div id="p3" class="playerBox" style="left:0;top:200px;color:#e07a00">
P4<br>Orange<div class="marbles"></div>
</div>

<canvas id="board" width="400" height="400"></canvas>
</div>

<script>
/* ===== CONFIG ===== */
const GRID = 5;
const CELL = 80;

/* ===== BOARD ===== */
const board = [
 [0,0,1,0,0],
 [0,0,0,0,0],
 [1,0,2,0,1],
 [0,0,0,0,0],
 [0,0,1,0,0]
];

/* ===== PATHS ===== */
let outerPath = [
 {x:0,y:0},{x:1,y:0},{x:2,y:0},{x:3,y:0},{x:4,y:0},
 {x:4,y:1},{x:4,y:2},{x:4,y:3},{x:4,y:4},
 {x:3,y:4},{x:2,y:4},{x:1,y:4},{x:0,y:4},
 {x:0,y:3},{x:0,y:2},{x:0,y:1}
].reverse(); // anticlockwise

const innerPath = [
 {x:2,y:3},
 {x:3,y:2},
 {x:2,y:1},
 {x:1,y:2}
];

/* ===== PLAYERS ===== */
const players = [
 {name:"P1", color:"#1f4fd8", start:{x:2,y:4}, tokens:[]},
 {name:"P2", color:"#1e8f3e", start:{x:4,y:2}, tokens:[]},
 {name:"P3", color:"#6a1fb0", start:{x:2,y:0}, tokens:[]},
 {name:"P4", color:"#e07a00", start:{x:0,y:2}, tokens:[]}
];

players.forEach(p=>{
 const idx = outerPath.findIndex(q=>q.x===p.start.x && q.y===p.start.y);
 for(let i=0;i<4;i++){
 p.tokens.push({
  mode:"outer",
  outerIndex:idx,
  innerIndex:0,
  finished:false,
  isAtHome:true,
  hasCaptured:false
 });
 }
});

let currentPlayer = 0;
let selectedToken = 0;
let grantExtraTurn = false;
let gameOver = false;  
const canvas = document.getElementById("board");
const ctx = canvas.getContext("2d");

const STACK = [
 {x:-12,y:-12},
 {x: 12,y:-12},
 {x:-12,y: 12},
 {x: 12,y: 12}
];

/* ===== ARROWS ===== */
function drawArrow(x1,y1,x2,y2){
 const h=7,a=Math.atan2(y2-y1,x2-x1);
 ctx.strokeStyle="#4a90e2";
 ctx.fillStyle="#4a90e2";
 ctx.lineWidth=3;
 ctx.beginPath();
 ctx.moveTo(x1,y1);ctx.lineTo(x2,y2);ctx.stroke();
 ctx.beginPath();
 ctx.moveTo(x2,y2);
 ctx.lineTo(x2-h*Math.cos(a-Math.PI/6),y2-h*Math.sin(a-Math.PI/6));
 ctx.lineTo(x2-h*Math.cos(a+Math.PI/6),y2-h*Math.sin(a+Math.PI/6));
 ctx.closePath();ctx.fill();
}

function drawPathArrows(path){
 for(let i=0;i<path.length;i++){
  const a=path[i],b=path[(i+1)%path.length];
  if(board[a.y][a.x]!==0||board[b.y][b.x]!==0)continue;
  drawArrow(
   a.x*CELL+CELL/2,a.y*CELL+CELL/2,
   b.x*CELL+CELL/2,b.y*CELL+CELL/2
  );
 }
}

/* ===== HELPERS ===== */
function tokenPosition(player, token) {
 if (token.finished) return null;
 if (token.isAtHome) return player.start;
 return token.mode === "outer" ? outerPath[token.outerIndex] : innerPath[token.innerIndex];
}

function buildPlayerGroups(player) {
 // returns map { "x,y": [tokenIndex, ...] } preserving token indices
 const groups = {};
 player.tokens.forEach((t, idx) => {
  if (t.finished) return;
  const pos = tokenPosition(player, t);
  if (!pos) return;
  const key = `${pos.x},${pos.y}`;
  if (!groups[key]) groups[key] = [];
  groups[key].push(idx);
 });
 return groups;
}

/* ===== TOKEN SELECTION ===== */
canvas.addEventListener("click", function (e) {

  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const player = players[currentPlayer];
  const groups = buildPlayerGroups(player);

  // iterate through grouped token indices to compute exact positions (same order as drawBoard)
  for (const key in groups) {
    const indices = groups[key];
    const [kx, ky] = key.split(",").map(Number);
    indices.forEach((tokenIdx, stackIdx) => {
      const cx = kx * CELL + CELL/2 + STACK[stackIdx].x;
      const cy = ky * CELL + CELL/2 + STACK[stackIdx].y;
      const dx = mx - cx;
      const dy = my - cy;
      if (Math.sqrt(dx * dx + dy * dy) <= 14) {
        selectedToken = tokenIdx;
        drawBoard();
      }
    });
  }
});

/* ===== DRAW ===== */
function drawBoard(){
 ctx.clearRect(0,0,400,400);

 for(let y=0;y<GRID;y++)for(let x=0;x<GRID;x++){
  ctx.fillStyle =
   board[y][x]===1?"#f4a261":
   board[y][x]===2?"#90dbf4":"#f8f8f8";
  ctx.fillRect(x*CELL,y*CELL,CELL,CELL);
  ctx.strokeRect(x*CELL,y*CELL,CELL,CELL);
 }

 drawPathArrows(outerPath);
 drawPathArrows(innerPath);

 players.forEach((p, pi)=>{
  const groups = buildPlayerGroups(p);
  Object.values(groups).forEach((tokenIndices)=>{
   tokenIndices.forEach((tokenIdx, i)=>{
    const t = p.tokens[tokenIdx];
    const pos = tokenPosition(p, t);
    if (!pos) return;
    ctx.beginPath();
    ctx.fillStyle = p.color;
    ctx.arc(
      pos.x*CELL + CELL/2 + STACK[i].x,
      pos.y*CELL + CELL/2 + STACK[i].y,
      (pi === currentPlayer && tokenIdx === selectedToken) ? 12 : 10,
      0,
      Math.PI*2
    );
    ctx.fill();

    // Highlight selected token
    if (pi === currentPlayer && tokenIdx === selectedToken) {
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 3;
    } else {
      ctx.strokeStyle = "#333";
      ctx.lineWidth = 1;
    }
    ctx.stroke();

   });
  });
 });

 document.querySelectorAll(".playerBox")
  .forEach((b,i)=>b.classList.toggle("active",i===currentPlayer));
}

/* ===== MARBLES ===== */
function drawMarbles(){
 document.querySelectorAll(".marbles").forEach(m=>m.innerHTML="");
 let box=document.querySelector(`#p${currentPlayer} .marbles`);
 let whites=0;
 for(let i=0;i<4;i++){
  let w=Math.random()<0.5;
  if(w)whites++;
  let d=document.createElement("div");
  d.className="marble "+(w?"white":"black");
  box.appendChild(d);
 }
 let token=players[currentPlayer].tokens[selectedToken];
 let steps=0;
 if(whites===1)steps=1;
 else if(whites===2)steps=2;
 else if(whites===3)steps=2;
 else if(whites===4)steps=token.mode==="outer"?8:9;
 else steps=4;

 return { steps, allSame:(whites===0||whites===4) };
}

/* ===== MOVE ===== */
function moveSteps(t,steps){
 if(t.isAtHome) return;
 while(steps--){
  if(t.mode==="outer"){
   t.outerIndex=(t.outerIndex+1)%outerPath.length;
   let p=outerPath[t.outerIndex];
   // INNER LOOP ENTRY — ONLY AFTER CAPTURE
   if (
     board[p.y][p.x] === 1 &&
     p.x === 2 &&
     p.y !== 2 &&
     t.hasCaptured === true
   ) {
     t.mode = "inner";
     t.innerIndex = 0;
   }
  }else{
   t.innerIndex++;
   if(t.innerIndex===innerPath.length){
    t.finished=true;
    break;
   }
  }
 }
}

/* ===== CAPTURE ===== */
function checkCapture(activePlayerIndex, activeToken) {
  // Only outer loop tokens can capture
  if (activeToken.mode !== "outer" || activeToken.isAtHome) return false;

  const pos = outerPath[activeToken.outerIndex];

  // No capture on safe zones
  if (board[pos.y][pos.x] === 1) return false;

  let capturedAnything = false;
  for (let p = 0; p < players.length; p++) {
    if (p === activePlayerIndex) continue;

    players[p].tokens.forEach(t => {
      if (
        !t.finished &&
        !t.isAtHome &&
        t.mode === "outer"
      ) {
        const tPos = outerPath[t.outerIndex];
        if (tPos.x === pos.x && tPos.y === pos.y) {

          // SEND OPPONENT TOKEN HOME
          t.isAtHome = true;
          t.outerIndex = outerPath.findIndex(
            q => q.x === players[p].start.x && q.y === players[p].start.y
          );
          t.innerIndex = 0;
          t.hasCaptured = false;

          // MARK CAPTURE
          activeToken.hasCaptured = true;
          capturedAnything = true;
        }
      }
    });
  }

  return capturedAnything;
}

/* ===== WIN ===== */
function checkWin(playerIndex) {
  const player = players[playerIndex];
  const finishedCount = player.tokens.filter(t => t.finished).length;

  if (finishedCount === 4) {
    gameOver = true;
    alert(player.name + " WINS THE GAME!");
  }
}

/* ===== TURN ===== */
function playTurn(){
  if (gameOver) return;
 const result = drawMarbles();
 const token = players[currentPlayer].tokens[selectedToken];

 // If token is at home, you can only enter on allSame (e.g., all black or all white)
 if (token.isAtHome) {
  if (result.allSame) {
    token.isAtHome = false;
    // ensure outerIndex remains at start (it already is)
    moveSteps(token, result.steps);
    checkCapture(currentPlayer, token);
  }
 } else {
  moveSteps(token, result.steps);
  const didCapture = checkCapture(currentPlayer, token);
  // optionally react to didCapture if needed
 }

 // Check win for active player
 checkWin(currentPlayer);

 // Determine extra turn
 grantExtraTurn = result.allSame;

 if (!gameOver) {
  if (!grantExtraTurn) {
    currentPlayer = (currentPlayer + 1) % 4;
    // reset selectedToken to 0 for next player (optional)
    selectedToken = 0;
  }
 }

 drawBoard();
}

drawBoard();
</script>
</body>
</html>
